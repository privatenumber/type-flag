"use strict";var D=Object.defineProperty;var a=(t,e)=>D(t,"name",{value:e,configurable:!0});const L="known-flag",O="unknown-flag",B="argument",K=/\B([A-Z])/g,R=a(t=>t.replaceAll(K,"-$1").toLowerCase(),"camelToKebab"),{hasOwnProperty:_}=Object.prototype,h=a((t,e)=>_.call(t,e),"hasOwn"),A=a(t=>typeof t=="function"?[t,!1]:Array.isArray(t)?[t[0],!0]:A(t.type),"parseFlagType"),m=a((t,e)=>t===Boolean?e!=="false":e,"normalizeBoolean"),V=a((t,e)=>typeof e=="boolean"?e:t===Number&&e===""?Number.NaN:t(e),"applyParser"),v=/[\s.:=]/,G=a(t=>{const e=`Flag name "${t}"`;if(t.length===0)throw new Error(`${e} cannot be empty`);const n=t.match(v);if(n)throw new Error(`${e} cannot contain "${n?.[0]}"`)},"validateFlagName"),b=a((t,e,n)=>{if(h(t,e))throw new Error(`Duplicate flags named "${e}"`);t[e]=n},"setFlag"),T=a(t=>{const e={};for(const n in t){if(!h(t,n))continue;G(n);const s=t[n],i=[[],...A(s),s];b(e,n,i);const o=R(n);if(n!==o&&b(e,o,i),"alias"in s&&typeof s.alias=="string"){const{alias:l}=s,r=`Flag alias "${l}" for flag "${n}"`;if(n.length===1)throw new Error(`${r} cannot be defined for a single-character flag`);if(l.length===0)throw new Error(`${r} cannot be empty`);if(l.length>1)throw new Error(`${r} must be a single character`);b(e,l,i)}}return e},"createRegistry"),U=a((t,e)=>{const n={};for(const s in t){if(!h(t,s))continue;const[i,,o,l]=e[s];if(i.length===0&&"default"in l){let{default:r}=l;typeof r=="function"&&(r=r()),n[s]=r}else n[s]=o?i:i.pop()}return n},"finalizeFlags"),F="--",W=/[.:=]/,j=/^-{1,2}\w/,E=a(t=>{if(!j.test(t))return;const e=!t.startsWith(F);let n=t.slice(e?1:2),s;const i=n.match(W);if(i){const{index:o}=i;s=n.slice(o+1),n=n.slice(0,o)}return[n,s,e]},"parseFlagArgv"),P=a((t,{onFlag:e,onArgument:n})=>{let s;const i=a((o,l)=>{if(typeof s!="function")return!0;s(o,l),s=void 0},"triggerValueCallback");for(let o=0;o<t.length;o+=1){const l=t[o];if(l===F){i();const c=t.slice(o+1);n?.(c,[o],!0);break}const r=E(l);if(r){if(i(),!e)continue;const[c,f,w]=r;if(w)for(let u=0;u<c.length;u+=1){i();const g=u===c.length-1;s=e(c[u],g?f:void 0,[o,u+1,g])}else s=e(c,f,[o])}else i(l,[o])&&n?.([l],[o])}i()},"argvIterator"),k=a((t,e)=>{for(let n=e.length-1;n>=0;n-=1){const[s,i,o]=e[n];if(i){const l=t[s];let r=l.slice(0,i);if(o||(r+=l.slice(i+1)),r!=="-"){t[s]=r;continue}}t.splice(s,1)}},"spliceFromArgv"),z=a((t,e=process.argv.slice(2),{ignore:n}={})=>{const s=[],i=T(t),o={},l=[];return l[F]=[],P(e,{onFlag(r,c,f){const g=(f.length===3||r.length>1)&&h(i,r);if(!n?.(g?L:O,r,c)){if(g){const[y,p]=i[r],d=m(p,c),N=a((C,$)=>{s.push(f),$&&s.push($),y.push(V(p,C||""))},"getFollowingValue");return d===void 0?N:N(d)}h(o,r)||(o[r]=[]),o[r].push(c===void 0?!0:c),s.push(f)}},onArgument:a((r,c,f)=>{n?.(B,e[c[0]])||(l.push(...r),f?(l[F]=r,e.splice(c[0])):s.push(c))},"onArgument")}),k(e,s),{flags:U(t,i),unknownFlags:o,_:l}},"typeFlag"),H=a((t,e,n=process.argv.slice(2))=>{const s=t.split(",").map(c=>E(c)?.[0]),[i,o]=A(e),l=[],r=[];return P(n,{onFlag:a((c,f,w)=>{if(!s.includes(c)||!o&&l.length>0)return;const u=m(i,f),g=a((y,p)=>{r.push(w),p&&r.push(p),l.push(V(i,y||""))},"getFollowingValue");return u===void 0?g:g(u)},"onFlag")}),k(n,r),o?l:l[0]},"getFlag");exports.getFlag=H,exports.typeFlag=z;
