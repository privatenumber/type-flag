"use strict";var O=Object.defineProperty;var a=(t,e)=>O(t,"name",{value:e,configurable:!0});const P="known-flag",_="unknown-flag",D="argument",B=/\B([A-Z])/g,G=a(t=>t.replaceAll(B,"-$1").toLowerCase(),"camelToKebab"),{hasOwnProperty:K}=Object.prototype,h=a((t,e)=>K.call(t,e),"hasOwn"),A=a(t=>typeof t=="function"?[t,!1]:Array.isArray(t)?[t[0],!0]:A(t.type),"parseFlagType"),$=a((t,e)=>t===Boolean?e!=="false":e,"normalizeBoolean"),m=a((t,e)=>typeof e=="boolean"?e:t===Number&&e===""?Number.NaN:t(e),"applyParser"),R=/[\s.:=]/,T=a(t=>{const e=`Flag name "${t}"`;if(t.length===0)throw new Error(`${e} cannot be empty`);if(t.length===1)throw new Error(`${e} must be longer than a character`);const n=t.match(R);if(n)throw new Error(`${e} cannot contain "${n?.[0]}"`)},"validateFlagName"),d=a((t,e,n)=>{if(h(t,e))throw new Error(`Duplicate flags named "${e}"`);t[e]=n},"setFlag"),U=a(t=>{const e={};for(const n in t){if(!h(t,n))continue;T(n);const s=t[n],r=[[],...A(s),s];d(e,n,r);const l=G(n);if(n!==l&&d(e,l,r),"alias"in s&&typeof s.alias=="string"){const{alias:o}=s,i=`Flag alias "${o}" for flag "${n}"`;if(o.length===0)throw new Error(`${i} cannot be empty`);if(o.length>1)throw new Error(`${i} must be a single character`);d(e,o,r)}}return e},"createRegistry"),W=a((t,e)=>{const n={};for(const s in t){if(!h(t,s))continue;const[r,,l,o]=e[s];if(r.length===0&&"default"in o){let{default:i}=o;typeof i=="function"&&(i=i()),n[s]=i}else n[s]=l?r:r.pop()}return n},"finalizeFlags"),F="--",j=3,v=/^-{1,2}\w/,V=a(t=>{if(!v.test(t))return;const e=!t.startsWith(F);let n=t.slice(e?1:2),s,r=-1;for(const l of["=",":","."]){const o=n.indexOf(l);o!==-1&&(r===-1||o<r)&&(r=o)}return r!==-1&&(s=n.slice(r+1),n=n.slice(0,r)),[n,s,e]},"parseFlagArgv"),L=a((t,{onFlag:e,onArgument:n})=>{let s;const r=a((l,o)=>{if(typeof s!="function")return!0;s(l,o),s=void 0},"triggerValueCallback");for(let l=0;l<t.length;l+=1){const o=t[l];if(o===F){r();const c=t.slice(l+1);n?.(c,[l],!0);break}const i=V(o);if(i){if(r(),!e)continue;const[c,f,w]=i;if(w)for(let u=0;u<c.length;u+=1){r();const g=u===c.length-1;s=e(c[u],g?f:void 0,[l,u+1,g])}else s=e(c,f,[l])}else r(o,[l])&&n?.([o],[l])}r()},"argvIterator"),k=a((t,e)=>{for(let n=e.length-1;n>=0;n-=1){const[s,r,l]=e[n];if(r){const o=t[s];let i=o.slice(0,r);if(l||(i+=o.slice(r+1)),i!=="-"){t[s]=i;continue}}t.splice(s,1)}},"spliceFromArgv"),z=a((t,e=process.argv.slice(2),{ignore:n}={})=>{const s=[],r=U(t),l={},o=[];return o[F]=[],L(e,{onFlag(i,c,f){const g=(f.length===j||i.length>1)&&h(r,i);if(!n?.(g?P:_,i,c)){if(g){const[y,p]=r[i],b=$(p,c),N=a((C,E)=>{s.push(f),E&&s.push(E),y.push(m(p,C||""))},"getFollowingValue");return b===void 0?N:N(b)}h(l,i)||(l[i]=[]),l[i].push(c===void 0?!0:c),s.push(f)}},onArgument:a((i,c,f)=>{n?.(D,e[c[0]])||(o.push(...i),f?(o[F]=i,e.splice(c[0])):s.push(c))},"onArgument")}),k(e,s),{flags:W(t,r),unknownFlags:l,_:o}},"typeFlag"),H=a((t,e,n=process.argv.slice(2))=>{const s=new Set(t.split(",").map(c=>V(c)?.[0])),[r,l]=A(e),o=[],i=[];return L(n,{onFlag:a((c,f,w)=>{if(!s.has(c)||!l&&o.length>0)return;const u=$(r,f),g=a((y,p)=>{i.push(w),p&&i.push(p),o.push(m(r,y||""))},"getFollowingValue");return u===void 0?g:g(u)},"onFlag")}),k(n,i),l?o:o[0]},"getFlag");exports.getFlag=H,exports.typeFlag=z;
