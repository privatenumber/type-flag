"use strict";var k=Object.defineProperty;var c=(t,n)=>k(t,"name",{value:n,configurable:!0});const C="known-flag",O="unknown-flag",v="argument",{stringify:w}=JSON,D=/\B([A-Z])/g,L=c(t=>t.replaceAll(D,"-$1").toLowerCase(),"camelToKebab"),{hasOwnProperty:R}=Object.prototype,y=c((t,n)=>R.call(t,n),"hasOwn"),B=c(t=>Array.isArray(t),"isReadonlyArray"),b=c(t=>typeof t=="function"?[t,!1]:B(t)?[t[0],!0]:b(t.type),"parseFlagType"),m=c((t,n)=>t===Boolean?n!=="false":n,"normalizeBoolean"),N=c((t,n)=>typeof n=="boolean"?n:t===Number&&n===""?Number.NaN:t(n),"applyParser"),K=/[\s.:=]/,_=c(t=>{const n=`Flag name ${w(t)}`;if(t.length===0)throw new Error(`${n} cannot be empty`);const r=t.match(K);if(r)throw new Error(`${n} cannot contain ${w(r?.[0])}`)},"validateFlagName"),G=c(t=>{const n={},r=c((e,o)=>{if(y(n,e))throw new Error(`Duplicate flags named ${w(e)}`);n[e]=o},"setFlag");for(const e in t){if(!y(t,e))continue;_(e);const o=t[e],s=[[],...b(o),o];r(e,s);const a=L(e);if(e!==a&&r(a,s),"alias"in o&&typeof o.alias=="string"){const{alias:i}=o,l=`Flag alias ${w(i)} for flag ${w(e)}`;if(e.length===1)throw new Error(`${l} cannot be defined for a single-character flag`);if(i.length===0)throw new Error(`${l} cannot be empty`);if(i.length>1)throw new Error(`${l} must be a single character`);r(i,s)}}return n},"createRegistry"),T=c((t,n)=>{const r={};for(const e in t){if(!y(t,e))continue;const[o,,s,a]=n[e];if(o.length===0&&"default"in a){let{default:i}=a;typeof i=="function"&&(i=i()),r[e]=i}else r[e]=s?o:o.pop()}return r},"finalizeFlags"),A="--",U=/[.:=]/,W=/^-{1,2}\w/,$=c(t=>{if(!W.test(t))return;const n=!t.startsWith(A);let r=t.slice(n?1:2),e;const o=r.match(U);if(o){const{index:s}=o;e=r.slice(s+1),r=r.slice(0,s)}return[r,e,n]},"parseFlagArgv"),E=c((t,{onFlag:n,onArgument:r})=>{let e;const o=c((s,a)=>{if(typeof e!="function")return!0;e(s,a),e=void 0},"triggerValueCallback");for(let s=0;s<t.length;s+=1){const a=t[s];if(a===A){o();const l=t.slice(s+1);r?.(l,[s],!0);break}const i=$(a);if(i){if(o(),!n)continue;const[l,u,p]=i;if(p)for(let f=0;f<l.length;f+=1){o();const g=f===l.length-1;e=n(l[f],g?u:void 0,[s,f+1,g])}else e=n(l,u,[s])}else o(a,[s])&&r?.([a],[s])}o()},"argvIterator"),P=c((t,n)=>{for(const[r,e,o]of n.reverse()){if(e){const s=t[r];let a=s.slice(0,e);if(o||(a+=s.slice(e+1)),a!=="-"){t[r]=a;continue}}t.splice(r,1)}},"spliceFromArgv"),j=c((t,n=process.argv.slice(2),{ignore:r}={})=>{const e=[],o=G(t),s={},a=[];return a[A]=[],E(n,{onFlag(i,l,u){const p=y(o,i);if(!r?.(p?C:O,i,l)){if(p){const[f,g]=o[i],F=m(g,l),h=c((V,d)=>{e.push(u),d&&e.push(d),f.push(N(g,V||""))},"getFollowingValue");return F===void 0?h:h(F)}y(s,i)||(s[i]=[]),s[i].push(l===void 0?!0:l),e.push(u)}},onArgument:(i,l,u)=>{r?.(v,n[l[0]])||(a.push(...i),u?(a[A]=i,n.splice(l[0])):e.push(l))}}),P(n,e),{flags:T(t,o),unknownFlags:s,_:a}},"typeFlag"),z=c((t,n,r=process.argv.slice(2))=>{const e=t.split(",").map(l=>$(l)?.[0]),[o,s]=b(n),a=[],i=[];return E(r,{onFlag:(l,u,p)=>{if(!e.includes(l)||!s&&a.length>0)return;const f=m(o,u),g=c((F,h)=>{i.push(p),h&&i.push(h),a.push(N(o,F||""))},"getFollowingValue");return f===void 0?g:g(f)}}),P(r,i),s?a:a[0]},"getFlag");exports.getFlag=z,exports.typeFlag=j;
