"use strict";var O=Object.defineProperty;var c=(t,s)=>O(t,"name",{value:s,configurable:!0});const v="known-flag",D="unknown-flag",L="argument",{stringify:h}=JSON,R=/\B([A-Z])/g,B=c(t=>t.replaceAll(R,"-$1").toLowerCase(),"camelToKebab"),{hasOwnProperty:K}=Object.prototype,w=c((t,s)=>K.call(t,s),"hasOwn"),_=c(t=>Array.isArray(t),"isReadonlyArray"),d=c(t=>typeof t=="function"?[t,!1]:_(t)?[t[0],!0]:d(t.type),"parseFlagType"),$=c((t,s)=>t===Boolean?s!=="false":s,"normalizeBoolean"),V=c((t,s)=>typeof s=="boolean"?s:t===Number&&s===""?Number.NaN:t(s),"applyParser"),G=/[\s.:=]/,T=c(t=>{const s=`Flag name ${h(t)}`;if(t.length===0)throw new Error(`${s} cannot be empty`);const r=t.match(G);if(r)throw new Error(`${s} cannot contain ${h(r?.[0])}`)},"validateFlagName"),U=c(t=>{const s={},r=c((e,o)=>{if(w(s,e))throw new Error(`Duplicate flags named ${h(e)}`);s[e]=o},"setFlag");for(const e in t){if(!w(t,e))continue;T(e);const o=t[e],n=[[],...d(o),o];r(e,n);const l=B(e);if(e!==l&&r(l,n),"alias"in o&&typeof o.alias=="string"){const{alias:i}=o,a=`Flag alias ${h(i)} for flag ${h(e)}`;if(e.length===1)throw new Error(`${a} cannot be defined for a single-character flag`);if(i.length===0)throw new Error(`${a} cannot be empty`);if(i.length>1)throw new Error(`${a} must be a single character`);r(i,n)}}return s},"createRegistry"),W=c((t,s)=>{const r={};for(const e in t){if(!w(t,e))continue;const[o,,n,l]=s[e];if(o.length===0&&"default"in l){let{default:i}=l;typeof i=="function"&&(i=i()),r[e]=i}else r[e]=n?o:o.pop()}return r},"finalizeFlags"),F="--",j=/[.:=]/,z=/^-{1,2}\w/,E=c(t=>{if(!z.test(t))return;const s=!t.startsWith(F);let r=t.slice(s?1:2),e;const o=r.match(j);if(o){const{index:n}=o;e=r.slice(n+1),r=r.slice(0,n)}return[r,e,s]},"parseFlagArgv"),P=c((t,{onFlag:s,onArgument:r})=>{let e;const o=c((n,l)=>{if(typeof e!="function")return!0;e(n,l),e=void 0},"triggerValueCallback");for(let n=0;n<t.length;n+=1){const l=t[n];if(l===F){o();const a=t.slice(n+1);r?.(a,[n],!0);break}const i=E(l);if(i){if(o(),!s)continue;const[a,f,y]=i;if(y)for(let u=0;u<a.length;u+=1){o();const g=u===a.length-1;e=s(a[u],g?f:void 0,[n,u+1,g])}else e=s(a,f,[n])}else o(l,[n])&&r?.([l],[n])}o()},"argvIterator"),k=c((t,s)=>{for(const[r,e,o]of s.reverse()){if(e){const n=t[r];let l=n.slice(0,e);if(o||(l+=n.slice(e+1)),l!=="-"){t[r]=l;continue}}t.splice(r,1)}},"spliceFromArgv"),H=c((t,s=process.argv.slice(2),{ignore:r}={})=>{const e=[],o=U(t),n={},l=[];return l[F]=[],P(s,{onFlag(i,a,f){const g=(f.length===3||i.length>1)&&w(o,i);if(!r?.(g?v:D,i,a)){if(g){const[A,p]=o[i],b=$(p,a),N=c((C,m)=>{e.push(f),m&&e.push(m),A.push(V(p,C||""))},"getFollowingValue");return b===void 0?N:N(b)}w(n,i)||(n[i]=[]),n[i].push(a===void 0?!0:a),e.push(f)}},onArgument:(i,a,f)=>{r?.(L,s[a[0]])||(l.push(...i),f?(l[F]=i,s.splice(a[0])):e.push(a))}}),k(s,e),{flags:W(t,o),unknownFlags:n,_:l}},"typeFlag"),J=c((t,s,r=process.argv.slice(2))=>{const e=t.split(",").map(a=>E(a)?.[0]),[o,n]=d(s),l=[],i=[];return P(r,{onFlag:(a,f,y)=>{if(!e.includes(a)||!n&&l.length>0)return;const u=$(o,f),g=c((A,p)=>{i.push(y),p&&i.push(p),l.push(V(o,A||""))},"getFollowingValue");return u===void 0?g:g(u)}}),k(r,i),n?l:l[0]},"getFlag");exports.getFlag=J,exports.typeFlag=H;
