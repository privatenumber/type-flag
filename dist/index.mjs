var O=Object.defineProperty;var c=(t,n)=>O(t,"name",{value:n,configurable:!0});const v="known-flag",D="unknown-flag",L="argument",{stringify:h}=JSON,R=/\B([A-Z])/g,B=c(t=>t.replaceAll(R,"-$1").toLowerCase(),"camelToKebab"),{hasOwnProperty:K}=Object.prototype,w=c((t,n)=>K.call(t,n),"hasOwn"),_=c(t=>Array.isArray(t),"isReadonlyArray"),d=c(t=>typeof t=="function"?[t,!1]:_(t)?[t[0],!0]:d(t.type),"parseFlagType"),$=c((t,n)=>t===Boolean?n!=="false":n,"normalizeBoolean"),V=c((t,n)=>typeof n=="boolean"?n:t===Number&&n===""?Number.NaN:t(n),"applyParser"),G=/[\s.:=]/,T=c(t=>{const n=`Flag name ${h(t)}`;if(t.length===0)throw new Error(`${n} cannot be empty`);const r=t.match(G);if(r)throw new Error(`${n} cannot contain ${h(r?.[0])}`)},"validateFlagName"),U=c(t=>{const n={},r=c((e,o)=>{if(w(n,e))throw new Error(`Duplicate flags named ${h(e)}`);n[e]=o},"setFlag");for(const e in t){if(!w(t,e))continue;T(e);const o=t[e],s=[[],...d(o),o];r(e,s);const l=B(e);if(e!==l&&r(l,s),"alias"in o&&typeof o.alias=="string"){const{alias:i}=o,a=`Flag alias ${h(i)} for flag ${h(e)}`;if(e.length===1)throw new Error(`${a} cannot be defined for a single-character flag`);if(i.length===0)throw new Error(`${a} cannot be empty`);if(i.length>1)throw new Error(`${a} must be a single character`);r(i,s)}}return n},"createRegistry"),W=c((t,n)=>{const r={};for(const e in t){if(!w(t,e))continue;const[o,,s,l]=n[e];if(o.length===0&&"default"in l){let{default:i}=l;typeof i=="function"&&(i=i()),r[e]=i}else r[e]=s?o:o.pop()}return r},"finalizeFlags"),A="--",j=/[.:=]/,z=/^-{1,2}\w/,E=c(t=>{if(!z.test(t))return;const n=!t.startsWith(A);let r=t.slice(n?1:2),e;const o=r.match(j);if(o){const{index:s}=o;e=r.slice(s+1),r=r.slice(0,s)}return[r,e,n]},"parseFlagArgv"),P=c((t,{onFlag:n,onArgument:r})=>{let e;const o=c((s,l)=>{if(typeof e!="function")return!0;e(s,l),e=void 0},"triggerValueCallback");for(let s=0;s<t.length;s+=1){const l=t[s];if(l===A){o();const a=t.slice(s+1);r?.(a,[s],!0);break}const i=E(l);if(i){if(o(),!n)continue;const[a,f,y]=i;if(y)for(let u=0;u<a.length;u+=1){o();const g=u===a.length-1;e=n(a[u],g?f:void 0,[s,u+1,g])}else e=n(a,f,[s])}else o(l,[s])&&r?.([l],[s])}o()},"argvIterator"),k=c((t,n)=>{for(const[r,e,o]of n.reverse()){if(e){const s=t[r];let l=s.slice(0,e);if(o||(l+=s.slice(e+1)),l!=="-"){t[r]=l;continue}}t.splice(r,1)}},"spliceFromArgv"),H=c((t,n=process.argv.slice(2),{ignore:r}={})=>{const e=[],o=U(t),s={},l=[];return l[A]=[],P(n,{onFlag(i,a,f){const g=(f.length===3||i.length>1)&&w(o,i);if(!r?.(g?v:D,i,a)){if(g){const[F,p]=o[i],b=$(p,a),N=c((C,m)=>{e.push(f),m&&e.push(m),F.push(V(p,C||""))},"getFollowingValue");return b===void 0?N:N(b)}w(s,i)||(s[i]=[]),s[i].push(a===void 0?!0:a),e.push(f)}},onArgument:(i,a,f)=>{r?.(L,n[a[0]])||(l.push(...i),f?(l[A]=i,n.splice(a[0])):e.push(a))}}),k(n,e),{flags:W(t,o),unknownFlags:s,_:l}},"typeFlag"),J=c((t,n,r=process.argv.slice(2))=>{const e=t.split(",").map(a=>E(a)?.[0]),[o,s]=d(n),l=[],i=[];return P(r,{onFlag:(a,f,y)=>{if(!e.includes(a)||!s&&l.length>0)return;const u=$(o,f),g=c((F,p)=>{i.push(y),p&&i.push(p),l.push(V(o,F||""))},"getFollowingValue");return u===void 0?g:g(u)}}),k(r,i),s?l:l[0]},"getFlag");export{J as getFlag,H as typeFlag};
