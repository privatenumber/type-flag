var k=Object.defineProperty;var c=(t,n)=>k(t,"name",{value:n,configurable:!0});const C="known-flag",O="unknown-flag",v="argument",{stringify:w}=JSON,D=/\B([A-Z])/g,L=c(t=>t.replaceAll(D,"-$1").toLowerCase(),"camelToKebab"),{hasOwnProperty:R}=Object.prototype,y=c((t,n)=>R.call(t,n),"hasOwn"),B=c(t=>Array.isArray(t),"isReadonlyArray"),b=c(t=>typeof t=="function"?[t,!1]:B(t)?[t[0],!0]:b(t.type),"parseFlagType"),m=c((t,n)=>t===Boolean?n!=="false":n,"normalizeBoolean"),N=c((t,n)=>typeof n=="boolean"?n:t===Number&&n===""?Number.NaN:t(n),"applyParser"),K=/[\s.:=]/,_=c(t=>{const n=`Flag name ${w(t)}`;if(t.length===0)throw new Error(`${n} cannot be empty`);const r=t.match(K);if(r)throw new Error(`${n} cannot contain ${w(r?.[0])}`)},"validateFlagName"),G=c(t=>{const n={},r=c((e,o)=>{if(y(n,e))throw new Error(`Duplicate flags named ${w(e)}`);n[e]=o},"setFlag");for(const e in t){if(!y(t,e))continue;_(e);const o=t[e],s=[[],...b(o),o];r(e,s);const i=L(e);if(e!==i&&r(i,s),"alias"in o&&typeof o.alias=="string"){const{alias:a}=o,l=`Flag alias ${w(a)} for flag ${w(e)}`;if(e.length===1)throw new Error(`${l} cannot be defined for a single-character flag`);if(a.length===0)throw new Error(`${l} cannot be empty`);if(a.length>1)throw new Error(`${l} must be a single character`);r(a,s)}}return n},"createRegistry"),T=c((t,n)=>{const r={};for(const e in t){if(!y(t,e))continue;const[o,,s,i]=n[e];if(o.length===0&&"default"in i){let{default:a}=i;typeof a=="function"&&(a=a()),r[e]=a}else r[e]=s?o:o.pop()}return r},"finalizeFlags"),A="--",U=/[.:=]/,W=/^-{1,2}\w/,$=c(t=>{if(!W.test(t))return;const n=!t.startsWith(A);let r=t.slice(n?1:2),e;const o=r.match(U);if(o){const{index:s}=o;e=r.slice(s+1),r=r.slice(0,s)}return[r,e,n]},"parseFlagArgv"),E=c((t,{onFlag:n,onArgument:r})=>{let e;const o=c((s,i)=>{if(typeof e!="function")return!0;e(s,i),e=void 0},"triggerValueCallback");for(let s=0;s<t.length;s+=1){const i=t[s];if(i===A){o();const l=t.slice(s+1);r?.(l,[s],!0);break}const a=$(i);if(a){if(o(),!n)continue;const[l,u,p]=a;if(p)for(let f=0;f<l.length;f+=1){o();const g=f===l.length-1;e=n(l[f],g?u:void 0,[s,f+1,g])}else e=n(l,u,[s])}else o(i,[s])&&r?.([i],[s])}o()},"argvIterator"),P=c((t,n)=>{for(const[r,e,o]of n.reverse()){if(e){const s=t[r];let i=s.slice(0,e);if(o||(i+=s.slice(e+1)),i!=="-"){t[r]=i;continue}}t.splice(r,1)}},"spliceFromArgv"),j=c((t,n=process.argv.slice(2),{ignore:r}={})=>{const e=[],o=G(t),s={},i=[];return i[A]=[],E(n,{onFlag(a,l,u){const p=y(o,a);if(!r?.(p?C:O,a,l)){if(p){const[f,g]=o[a],F=m(g,l),h=c((V,d)=>{e.push(u),d&&e.push(d),f.push(N(g,V||""))},"getFollowingValue");return F===void 0?h:h(F)}y(s,a)||(s[a]=[]),s[a].push(l===void 0?!0:l),e.push(u)}},onArgument:(a,l,u)=>{r?.(v,n[l[0]])||(i.push(...a),u?(i[A]=a,n.splice(l[0])):e.push(l))}}),P(n,e),{flags:T(t,o),unknownFlags:s,_:i}},"typeFlag"),z=c((t,n,r=process.argv.slice(2))=>{const e=t.split(",").map(l=>$(l)?.[0]),[o,s]=b(n),i=[],a=[];return E(r,{onFlag:(l,u,p)=>{if(!e.includes(l)||!s&&i.length>0)return;const f=m(o,u),g=c((F,h)=>{a.push(p),h&&a.push(h),i.push(N(o,F||""))},"getFollowingValue");return f===void 0?g:g(f)}}),P(r,a),s?i:i[0]},"getFlag");export{z as getFlag,j as typeFlag};
