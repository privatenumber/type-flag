var O=Object.defineProperty;var c=(t,e)=>O(t,"name",{value:e,configurable:!0});const v="known-flag",D="unknown-flag",L="argument",{stringify:h}=JSON,R=/\B([A-Z])/g,B=c(t=>t.replaceAll(R,"-$1").toLowerCase(),"camelToKebab"),{hasOwnProperty:K}=Object.prototype,w=c((t,e)=>K.call(t,e),"hasOwn"),_=c(t=>Array.isArray(t),"isReadonlyArray"),b=c(t=>typeof t=="function"?[t,!1]:_(t)?[t[0],!0]:b(t.type),"parseFlagType"),$=c((t,e)=>t===Boolean?e!=="false":e,"normalizeBoolean"),V=c((t,e)=>typeof e=="boolean"?e:t===Number&&e===""?Number.NaN:t(e),"applyParser"),G=/[\s.:=]/,T=c(t=>{const e=`Flag name ${h(t)}`;if(t.length===0)throw new Error(`${e} cannot be empty`);if(t.length===1)throw new Error(`${e} must be longer than a character`);const r=t.match(G);if(r)throw new Error(`${e} cannot contain ${h(r?.[0])}`)},"validateFlagName"),U=c(t=>{const e={},r=c((s,o)=>{if(w(e,s))throw new Error(`Duplicate flags named ${h(s)}`);e[s]=o},"setFlag");for(const s in t){if(!w(t,s))continue;T(s);const o=t[s],n=[[],...b(o),o];r(s,n);const l=B(s);if(s!==l&&r(l,n),"alias"in o&&typeof o.alias=="string"){const{alias:i}=o,a=`Flag alias ${h(i)} for flag ${h(s)}`;if(i.length===0)throw new Error(`${a} cannot be empty`);if(i.length>1)throw new Error(`${a} must be a single character`);r(i,n)}}return e},"createRegistry"),W=c((t,e)=>{const r={};for(const s in t){if(!w(t,s))continue;const[o,,n,l]=e[s];if(o.length===0&&"default"in l){let{default:i}=l;typeof i=="function"&&(i=i()),r[s]=i}else r[s]=n?o:o.pop()}return r},"finalizeFlags"),A="--",j=/[.:=]/,z=/^-{1,2}\w/,E=c(t=>{if(!z.test(t))return;const e=!t.startsWith(A);let r=t.slice(e?1:2),s;const o=r.match(j);if(o){const{index:n}=o;s=r.slice(n+1),r=r.slice(0,n)}return[r,s,e]},"parseFlagArgv"),P=c((t,{onFlag:e,onArgument:r})=>{let s;const o=c((n,l)=>{if(typeof s!="function")return!0;s(n,l),s=void 0},"triggerValueCallback");for(let n=0;n<t.length;n+=1){const l=t[n];if(l===A){o();const a=t.slice(n+1);r?.(a,[n],!0);break}const i=E(l);if(i){if(o(),!e)continue;const[a,f,y]=i;if(y)for(let u=0;u<a.length;u+=1){o();const g=u===a.length-1;s=e(a[u],g?f:void 0,[n,u+1,g])}else s=e(a,f,[n])}else o(l,[n])&&r?.([l],[n])}o()},"argvIterator"),k=c((t,e)=>{for(const[r,s,o]of e.reverse()){if(s){const n=t[r];let l=n.slice(0,s);if(o||(l+=n.slice(s+1)),l!=="-"){t[r]=l;continue}}t.splice(r,1)}},"spliceFromArgv"),H=c((t,e=process.argv.slice(2),{ignore:r}={})=>{const s=[],o=U(t),n={},l=[];return l[A]=[],P(e,{onFlag(i,a,f){const g=(f.length===3||i.length>1)&&w(o,i);if(!r?.(g?v:D,i,a)){if(g){const[F,p]=o[i],d=$(p,a),m=c((C,N)=>{s.push(f),N&&s.push(N),F.push(V(p,C||""))},"getFollowingValue");return d===void 0?m:m(d)}w(n,i)||(n[i]=[]),n[i].push(a===void 0?!0:a),s.push(f)}},onArgument:(i,a,f)=>{r?.(L,e[a[0]])||(l.push(...i),f?(l[A]=i,e.splice(a[0])):s.push(a))}}),k(e,s),{flags:W(t,o),unknownFlags:n,_:l}},"typeFlag"),J=c((t,e,r=process.argv.slice(2))=>{const s=t.split(",").map(a=>E(a)?.[0]),[o,n]=b(e),l=[],i=[];return P(r,{onFlag:(a,f,y)=>{if(!s.includes(a)||!n&&l.length>0)return;const u=$(o,f),g=c((F,p)=>{i.push(y),p&&i.push(p),l.push(V(o,F||""))},"getFollowingValue");return u===void 0?g:g(u)}}),k(r,i),n?l:l[0]},"getFlag");export{J as getFlag,H as typeFlag};
